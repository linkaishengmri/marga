#+TITLE: FLOCRA - an experimental flow-based MRI console compatible with the OCRA hardware platform

** Instruction set
   
*** General thoughts
    
    Single device: 32 ADC inputs (0b each, just 'acquire') -> 5b information, 32 RF outputs (16b each) -> 21b information, 32 grad outputs (24b each) -> 29b each.

    Also want a time delay built into the instruction, at least sufficient to provide simultaneous updates on every channel if they're written in a row (i.e. 32 + 32 + 32 = 7 bits)

    Buffers/blockers of 1-element depth for each output stream

    up to 128 unique 16b output buffers (start with far fewer).

    For now, just 24 unique 16b output buffers; 16 are real-time with flow control/error checking, 8 are for intermediate configuration and setting changes.

*** Basic types, all 32 bits

    Type A: 1b zero, 7b instruction, 24b payload (internal delays, external trigger, config, memory offset, start/stop execution, other settings)
    
    Type B: 1b one, 7b target, 8b time, 16b payload (external buffers and their delays)

    - Pipelined dataflow for the external buffers; extra latency but this is compensated in the timeouts/ready flags coming back to FSM
      
    - One instruction per cycle

    - Type A: exclusive main FSM timing, containing everything needed

    - Type B: exclusive external-buffer data/timing

    External buffers can themselves internally have some FIFO depth (and timers), in case bursts are desired - e.g. for occasional really rapid TX or RX sequences (though the RX will probably just have a separate FSM for timing itself).

    Each external buffer can flag an error if too much data is pushed to it, and this will make its way up a chain of ORs to a central error register

*** Different output buffers 

    - TX buffer inputs: 16b data, 8b time, 1b valid, outputs: 16b data, 1b valid (maybe unused), 1b error. [Initially, 4 TX buffers, whose outputs will just go to the existing complex multipliers.]

    - Grad buffer inputs: 16b data, 8b time (MSB interpreted as hi/lo), 1b valid.

    - General buffer inputs: like TX

*** Write registers

    - 24b of memory space

*** Read-only registers

    - Current address (24b memory space)

    - Cycles since start of execution

    - Errors (latch each input bit until reset occurs)

    - Status (no latch, just allow for read-out)

** Plan

   Write the output buffer core, with empty/full status outputs as well as data strobe

   When the FIFO has data written to it, it should increment the input ptr and flag the data as valid.
   Having been flagged, data should start a countdown (as short as 1 cycle).
   Having counted down, data should increment its address and, if that's already the input ptr, return to idle. If it's not, then repeat until the addresses are equalised.

   Write the main FSM and instruction BRAM: use the empty

   Start by writing the main instruction BRAM, the output FSM (with PC logic)

   
** Instruction set quirks

   Don't write to a buffer in two successive clock cycles if you can
   avoid it - the FULL flag only goes high a clock cycle after a
   buffer is written to. Still fine to record FULL events when writes
   occurred though (for exception recording).

   Error handling: any error line strobed by a buffer will be latched
   into the error register, bits 31-16. If a FIFO is full when it is
   written to, this will be caught, the error latched into the error
   register bit 31, and the current buffer index saved to bits 30:24.

** Running unit tests with Verilator   

   Need to extend marcos_server with either some ifdef code or some custom classes that implement low-level pointer access.

   Just use the hardware's memory map.

   New functions to make pointer access transparent: =hw_rd()= and =hw_wr()=.

   Make this better later on. May become harder to simulate slave writes, but probably not too bad with a memory-mapped file.
